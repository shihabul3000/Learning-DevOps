===============================================================================
                    RAW NODE.JS TYPESCRIPT SERVER - COMPLETE RECREATION GUIDE
===============================================================================

PROJECT OVERVIEW:
This is a raw Node.js HTTP server built with TypeScript that implements:
- Custom routing system without any frameworks
- JSON response handling utilities
- Request body parsing for POST requests
- Environment configuration with dotenv
- Modular architecture with separated concerns

TECH STACK:
- Node.js (raw HTTP module)
- TypeScript
- dotenv for environment variables
- ts-node-dev for development

===============================================================================
                                STEP-BY-STEP RECREATION
===============================================================================

STEP 1: PROJECT INITIALIZATION
------------------------------
1. Create project directory:
   mkdir my-raw-nodejs-server
   cd my-raw-nodejs-server

2. Initialize npm project:
   npm init -y

3. Install dependencies:
   npm install dotenv

4. Install development dependencies:
   npm install -D typescript @types/node ts-node ts-node-dev

STEP 2: TYPESCRIPT CONFIGURATION SETUP
--------------------------------------

IMPORTANT: How to get tsconfig.json - You have 3 options:

OPTION 1: Generate automatically (RECOMMENDED)
   npm install -g typescript
   npx tsc --init
   # Then replace the generated content with the configuration below

OPTION 2: Create manually
   # Create tsconfig.json file and copy the content below

OPTION 3: Copy from existing project
   # If you already have a tsconfig.json, you can copy it

STEP 3: PROJECT CONFIGURATION FILES
-----------------------------------

FILE: package.json (Update scripts section)
{
  "name": "module-11-raw-nodejs",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "dev": "ts-node-dev --respawn --transpile-only ./src/server.ts",
    "build": "tsc"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@types/node": "^24.10.1",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.9.3"
  },
  "dependencies": {
    "dotenv": "^17.2.3"
  }
}

FILE: tsconfig.json
{
  "compilerOptions": {
    "rootDir": "./src",
    "outDir": "./dist",
    "module": "nodenext",
    "target": "esnext",
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "strict": true,
    "isolatedModules": true,
    "noUncheckedSideEffectImports": true,
    "moduleDetection": "force",
    "skipLibCheck": true
  }
}

FILE: .env
NODE_ENV=development
PORT=5000

FILE: .gitignore
node_modules
.env*

STEP 4: CREATE FOLDER STRUCTURE
-------------------------------
Create the following folder structure:
src/
├── config/
│   └── index.ts
├── helpers/
│   └── route-handler.ts
├── Pars/
│   └── parse-body.ts
├── Routes/
│   └── index.ts
├── server.ts
└── send-json.ts

STEP 5: IMPLEMENT CORE FILES
----------------------------

FILE: src/config/index.ts
import dotenv from "dotenv"
import path from "path"

dotenv.config({path : path.join(process.cwd(), ".env")})

const config = {
    env : process.env.NODE_ENV || 'development',
    port : process.env.PORT ? Number(process.env.PORT) : 5000
}

export default config

FILE: src/send-json.ts
import { ServerResponse } from "http";

function sendJson( res : ServerResponse , statusCode : number , data : any  ){
    res.writeHead(statusCode , {"content-type" : "application/json"})
    res.end(JSON.stringify(data))
}

export default sendJson;

FILE: src/helpers/route-handler.ts
import { IncomingMessage, ServerResponse } from "node:http";

export type RoteHandler = (req : IncomingMessage , res : ServerResponse) => void;
export const routes : Map<string,Map<string, RoteHandler>> = new Map()

function addRoute(method : string , path : string, handler : RoteHandler ) {
    if(!routes.has(method)) routes.set(method,new Map());
    routes.get(method)!.set(path,handler);
}

export default addRoute;

FILE: src/Pars/parse-body.ts
import { IncomingMessage } from "http";

async function parseBody (req : IncomingMessage) : Promise<any> {
    
    return new Promise((resolve , reject)=>{

        // Collect chunks
        let body = "";
       req.on("data" , (chunk) =>{
        body += chunk.toString();
       });

       // Finish
       req.on("end",() =>{
        try {
        resolve (body?JSON.parse(body) : {});
        }
        catch(err : any) 
        {
            reject(err)
        }
       })

       req.on("error" , reject);
    })
}

export default parseBody;

FILE: src/Routes/index.ts
import addRoute from "../helpers/route-handler"
import parseBody from "../Pars/parse-body"
import sendJson from "../send-json"

addRoute('GET' , '/' , (req , res)=>{
  sendJson(res , 200 , {
    message : "Hello! Server is running",
    path : req.url,
  } )
})

addRoute("GET", "/api" , (req , res)=>{
    sendJson(res , 200,{
        message : "This is an API route",
        path : req.url,
    })
})

addRoute("POST" , "/api/users" , async(req,res) =>{
 const body = await parseBody(req);
 sendJson(res, 201 , {success : true, data: body} );
});

FILE: src/server.ts
import http,{IncomingMessage, Server , ServerResponse}from "http";
import config from "./config";
import addRoute, { RoteHandler, routes } from "./helpers/route-handler";
import "./Routes"

const server : Server = http.createServer((req : IncomingMessage , res : ServerResponse) =>{

    const method = req.method?.toUpperCase() || "";
    const path = req.url || "";

    const methodMap = routes.get(method)
    const handler : RoteHandler | undefined = methodMap?.get(path)

    if(handler){
       handler(req, res);
    }
    else{
        res.writeHead(404 , {"content-type" : "application/json"})
        res.end(JSON.stringify({
            success : false,
            message : "Route not found !!!",
            path : req.url,
        }));
    }
})

server.listen(config.port,()=> {
    console.log(`Server is running on PORT ${config.port}`)
})

===============================================================================
                                HOW TO RUN THE PROJECT
===============================================================================

UNDERSTANDING THE BUILD PROCESS:
-------------------------------
When you run "npm run build", TypeScript compiler (tsc) will:
- Read your .ts files from src/ folder
- Compile them to .js files
- Put compiled JavaScript in dist/ folder
- Create the same folder structure in dist/

Example: src/server.ts becomes dist/server.js

THE DIST FOLDER:
After building, you'll see:
dist/
├── config/
│   └── index.js
├── helpers/
│   └── route-handler.js  
├── Pars/
│   └── parse-body.js
├── Routes/
│   └── index.js
├── server.js
└── send-json.js

RUNNING THE PROJECT:
-------------------
1. DEVELOPMENT MODE (runs TypeScript directly):
   npm run dev

2. BUILD FOR PRODUCTION (compiles to JavaScript):
   npm run build

3. RUN COMPILED VERSION (production):
   node dist/server.js

4. TEST THE ENDPOINTS:
   
   GET Request to root:
   curl http://localhost:5000/
   
   GET Request to API:
   curl http://localhost:5000/api
   
   POST Request with JSON data:
   curl -X POST http://localhost:5000/api/users \
        -H "Content-Type: application/json" \
        -d '{"name":"John", "email":"john@example.com"}'

===============================================================================
                                PROJECT ARCHITECTURE EXPLAINED
===============================================================================

1. SERVER.TS (Main Entry Point):
   - Creates HTTP server using Node.js built-in http module
   - Handles incoming requests and routes them to appropriate handlers
   - Returns 404 for unmatched routes

2. ROUTE-HANDLER.TS (Routing System):
   - Implements custom routing using Map data structure
   - Maps HTTP methods and paths to handler functions
   - No external routing library needed

3. SEND-JSON.TS (Response Utility):
   - Standardizes JSON responses
   - Sets proper content-type headers
   - Handles status codes consistently

4. PARSE-BODY.TS (Request Parser):
   - Manually parses incoming request body
   - Handles JSON parsing with error handling
   - Uses Node.js streams (data, end, error events)

5. CONFIG/INDEX.TS (Environment Setup):
   - Loads environment variables using dotenv
   - Provides centralized configuration
   - Sets default values for missing env vars

6. ROUTES/INDEX.TS (Route Definitions):
   - Defines all API endpoints
   - Uses the addRoute helper to register routes
   - Demonstrates GET and POST request handling

===============================================================================
                                KEY LEARNING CONCEPTS
===============================================================================

1. RAW NODE.JS HTTP SERVER:
   - No Express.js or other frameworks
   - Direct use of Node.js http module
   - Understanding of request/response cycle

2. CUSTOM ROUTING SYSTEM:
   - Map-based route storage
   - Method and path matching
   - Handler function execution

3. TYPESCRIPT INTEGRATION:
   - Strong typing for HTTP objects
   - Type definitions for custom functions
   - Compilation to JavaScript

4. MODULAR ARCHITECTURE:
   - Separation of concerns
   - Reusable utility functions
   - Clean code organization

5. ENVIRONMENT CONFIGURATION:
   - dotenv for environment variables
   - Configuration centralization
   - Development vs production settings

6. REQUEST/RESPONSE HANDLING:
   - Manual body parsing
   - JSON response formatting
   - Error handling

7. ASYNCHRONOUS PROGRAMMING:
   - Promise-based body parsing
   - Async/await for route handlers
   - Event-driven request processing

===============================================================================
                                POSSIBLE EXTENSIONS
===============================================================================

1. Add middleware system
2. Implement file upload handling
3. Add authentication/authorization
4. Include request logging
5. Add CORS support
6. Implement rate limiting
7. Add input validation
8. Include error handling middleware
9. Add database integration
10. Implement WebSocket support

===============================================================================
                                COMPLETE SETUP PROCESS (EXACT ORDER)
===============================================================================

Follow these steps in EXACT order:

1. CREATE PROJECT:
   mkdir my-raw-nodejs-server
   cd my-raw-nodejs-server

2. INITIALIZE NPM:
   npm init -y

3. INSTALL DEPENDENCIES:
   npm install dotenv
   npm install -D typescript @types/node ts-node ts-node-dev

4. GENERATE TSCONFIG.JSON:
   npx tsc --init
   # Then replace content with the tsconfig.json shown above

5. UPDATE PACKAGE.JSON:
   # Add the scripts section shown above

6. CREATE FOLDER STRUCTURE:
   mkdir src
   mkdir src/config src/helpers src/Pars src/Routes

7. CREATE ALL .TS FILES:
   # Copy all the file contents from Step 5 above

8. CREATE .ENV FILE:
   # Copy the .env content shown above

9. CREATE .GITIGNORE:
   # Copy the .gitignore content shown above

10. RUN DEVELOPMENT SERVER:
    npm run dev

11. BUILD FOR PRODUCTION (OPTIONAL):
    npm run build
    # This creates the dist/ folder with compiled JavaScript

===============================================================================
                                TROUBLESHOOTING
===============================================================================

COMMON ISSUES:

1. "tsc command not found":
   - Install TypeScript: npm install -g typescript
   - Or use: npx tsc --init

2. Port already in use:
   - Change PORT in .env file
   - Kill existing process: netstat -ano | findstr :5000

3. TypeScript compilation errors:
   - Check tsconfig.json configuration
   - Ensure all dependencies are installed
   - Make sure you generated tsconfig.json properly

4. Module not found errors:
   - Verify file paths and imports
   - Check case sensitivity in file names
   - Ensure you created all folders correctly

5. JSON parsing errors:
   - Ensure Content-Type header is set
   - Validate JSON format in requests

6. Route not found:
   - Check exact path matching
   - Verify HTTP method (GET/POST)
   - Ensure routes are imported in server.ts

7. "Cannot find module" after build:
   - Make sure you installed all dependencies
   - Check that dist/ folder was created properly
   - Verify tsconfig.json outDir is set to "./dist"

===============================================================================
                                END OF GUIDE
===============================================================================

This guide provides everything needed to recreate the raw Node.js TypeScript server.
Follow the steps in order, and you'll have a fully functional HTTP server without
any external frameworks, giving you deep understanding of how web servers work
at the fundamental level.